# Bithug

## Description

Code management software is way too bloated. Try our new lightweight solution, BitHug.
Source: [https://venus.picoctf.net/static/cad0d18de5489c4be3241c9ab7ba27a6/distribution.tgz](distribution.tgz)

## Hints

1. Every user gets their own target repository to attack called `_/.git`, but no permission to read it

## Rationale

Upon inspecting the source code of the web service, we see some interesting pieces of code.

In `auth-api.ts`:

```typescript
router.use("/", async (req, res, next) => {
    const token = req.cookies["user-token"];
    if (typeof token === "string") {
        const user = await authManager.userFromToken(token);
        if (user) {
            req.user = { kind: "user", user };
            return next();
        }
    }

    const authHeader = req.header("authorization");
    if (authHeader && authHeader.toLowerCase().startsWith("basic")) {
        const [user, password] = Buffer.from(authHeader.slice(6), "base64").toString().split(":");
        if (await authManager.login(user, password)) {
            req.user = { kind: "user", user };
            return next();
        }
    }

    const sourceIp = req.socket.remoteAddress;
    if (sourceIp === "127.0.0.1" || sourceIp === "::1" || sourceIp === "::ffff:127.0.0.1") {
        req.user = { kind: "admin" };
        return next();
    }

    req.user = { kind: "none" };
    return next();
});
```

Here any requests coming from localhost is considered privileged. This is highly indicative of an SSRF vulnerability.

In `web-api.ts`:

```typescript
router.use("/api/register", bodyParser.json());
router.post("/api/register", async (req, res) => {
    const { user, password } = req.body;
    if (typeof user !== "string"
        || !user.match(/^[a-zA-Z0-9-_]{3,}$/)
        || typeof password !== "string"
    ) {
        return res.status(400).send({ error: "Invalid username"});
    }

    await authManager.register(user, password);
    const token = await authManager.createToken(user);
    res.cookie("user-token", token);

    // Every user gets their own target to attack. Please do not try to
    // attack someone else's target.
    const targetRepo = new GitManager(`_/${user}.git`);
    await targetRepo.create();
    await targetRepo.initializeReadme(`
## Super Secret Admin Repo

The flag is \`${process.env.FLAG ?? "picoCTF{this_is_a_test_flag}"}\`
`);
    return res.send({});
});
```

Every time a new user is registered, the Bithug instance creates a repo only accessible by admin called `_/<username>.git`. This repository contains the flag. This means we have to gain access to the content of the repo.

Upon browsing the site, we also see two interesting features:

1. The user can add a webhook for the server to send a request to whenever a repo is pushed to.
2. The user can add users to a repo by creating `access.conf` and pushing it to a special branch `refs/meta/config`.

The webhook is most likely meant for us to exploit that fact that all requests from localhost is admin. The `access.conf` feature is also likely to be meant for us to add ourselves to the `_/<username>.git` repository.

However, the Bithug instance prevents us from adding a webhook that accesses localhost:

In `git-api.ts`:

```typescript
router.post("/:user/:repo.git/webhooks", async (req, res) => {
    if (req.user.kind === "admin" || req.user.kind === "none") {
        return res.status(400).end();
    }

    const { url, body, contentType } = req.body;
    const validationUrl = new URL(url);
    if (validationUrl.port !== "" && validationUrl.port !== "80") {
        throw new Error("Url must go to port 80");
    }
    if (validationUrl.host === "localhost" || validationUrl.host === "127.0.0.1") {
        throw new Error("Url must not go to localhost");
    }

    if (typeof contentType !== "string" || typeof body !== "string") {
        throw new Error("Bad arguments");
    }
    const trueBody = Buffer.from(body, "base64");

    await webhookManager.addWebhook(req.git.repo, req.user.user, url, contentType, trueBody);
    return res.send({});
});
```

Internally, the server is hosted on port `1823` and thus port 80 can not be used for the Bithug instance to access itself. Additionally, the server prevents us from creating a webhook with a localhost target url.

To get around this limitation, we can create an external web service that returns a [307 Temporary Redirect](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307). This redirect status code can redirect the client to another url and is guaranteed to keep the HTTP method and body.

In this example, we create a web service that returns a redirect to `http://localhost:1823/<path>`. By using this url for the webhook, all webhook calls are redirected back to the server.

Another interesting point is that despite the fact that we are presented with two content types for the webhook on the user interface, we can specify another content type and the server does not validate this new content type.

Thus the required steps for us to solve Bithug is the following:

1. Create a web service that returns a [307 Temporary Redirect](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307) back to `localhost:80`, keeping the same URL, body, and method.
2. Create an repository on the target Bithug instance.
3. Create a webhook that points to the redirect web service. The path should be `/_/<username>.git/git-receive-pack`, the content type should be `application/x-git-receive-pack-request`, and the body should be the data generated by [`git-send-pack`](https://git-scm.com/docs/git-send-pack) to push `access.conf` to the server.
4. Push a commit to the repository. Interally the Bithug instance sends a request to our redirect web service, but the request is bounced back to localhost to push a commit for us as admin.
5. Pull the target repository (`_/<username>.git`).
6. Read the flag. :D

To obtain the body for the webhook, we can patch the Bithug server to print the data for commits being pushed in base64.

In `git.ts`:

```typescript
public async receivePackPost(res: Response, data: Buffer) {
    console.log(data.toString('base64'));
    const results = await this.git("receive-pack", ["--stateless-rpc", this.dir], data);
    console.log(results.toString('base64'));
    res.send(results);
    const [refUpdate] = data.toString().split("\0");
    const [_old, _new, ref] = refUpdate.split(" ");
    return ref;
}
```

After creating an empty repository with the correct `access.conf` committed, we can manually push the repository to our local Bithug server to get the correct body. Note that the API for creating a webhook itself accepts a base64 string for the body.

## Running the script

First download the source code for Bithug, and patch the server as described above. Create a repository with `access.conf` containing your username similar to the one in the `magicrepo` directory. Run the Bithug instance and push the repository to obtain the body for the webhook. Save this value in the `magic` file under the `script` directory.

Then enter the `redirect` directory and run the flask server. You can expose the server using ngrok or plain old port-fowarding.

Finally, enter the `script` directory and configure the script in `settings.py`. Then run `register.py` to register an account on the Bithug instance, and run `main.py` to gain access to the target repository (`_/<username>.git`).

All there is left to do is to pull `_/<username>.git`!

Note that the script is preconfigured for the user `MehMehMeh`.

## Flag

`picoCTF{good_job_at_gitting_good}`
